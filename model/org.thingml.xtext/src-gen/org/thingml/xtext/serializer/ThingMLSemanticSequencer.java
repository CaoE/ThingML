/**
 * Copyright (C) 2014 SINTEF <franck.fleurey@sintef.no>
 *
 * Licensed under the GNU LESSER GENERAL PUBLIC LICENSE, Version 3, 29 June 2007;
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * generated by Xtext 2.9.1
 */
package org.thingml.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.thingml.xtext.services.ThingMLGrammarAccess;
import org.thingml.xtext.thingML.ActionBlock;
import org.thingml.xtext.thingML.ArrayParamRef;
import org.thingml.xtext.thingML.CompositeState;
import org.thingml.xtext.thingML.ConditionalAction;
import org.thingml.xtext.thingML.ConfigPropertyAssign;
import org.thingml.xtext.thingML.Configuration;
import org.thingml.xtext.thingML.Connector;
import org.thingml.xtext.thingML.Decrement;
import org.thingml.xtext.thingML.Enumeration;
import org.thingml.xtext.thingML.EnumerationLiteral;
import org.thingml.xtext.thingML.ErrorAction;
import org.thingml.xtext.thingML.ExternExpression;
import org.thingml.xtext.thingML.ExternStatement;
import org.thingml.xtext.thingML.ExternalConnector;
import org.thingml.xtext.thingML.Filter;
import org.thingml.xtext.thingML.FinalState;
import org.thingml.xtext.thingML.Function;
import org.thingml.xtext.thingML.FunctionCallStatement;
import org.thingml.xtext.thingML.Increment;
import org.thingml.xtext.thingML.Instance;
import org.thingml.xtext.thingML.InstanceRef;
import org.thingml.xtext.thingML.InternalPort;
import org.thingml.xtext.thingML.InternalTransition;
import org.thingml.xtext.thingML.JoinSources;
import org.thingml.xtext.thingML.LengthArray;
import org.thingml.xtext.thingML.LengthWindow;
import org.thingml.xtext.thingML.LocalVariable;
import org.thingml.xtext.thingML.LoopAction;
import org.thingml.xtext.thingML.MergeSources;
import org.thingml.xtext.thingML.Message;
import org.thingml.xtext.thingML.MessageParameter;
import org.thingml.xtext.thingML.ObjectType;
import org.thingml.xtext.thingML.ParallelRegion;
import org.thingml.xtext.thingML.PlatformAnnotation;
import org.thingml.xtext.thingML.PrimitiveType;
import org.thingml.xtext.thingML.PrintAction;
import org.thingml.xtext.thingML.Property;
import org.thingml.xtext.thingML.PropertyAssign;
import org.thingml.xtext.thingML.Protocol;
import org.thingml.xtext.thingML.ProvidedPort;
import org.thingml.xtext.thingML.ReceiveMessage;
import org.thingml.xtext.thingML.RequiredPort;
import org.thingml.xtext.thingML.ReturnAction;
import org.thingml.xtext.thingML.SendAction;
import org.thingml.xtext.thingML.Session;
import org.thingml.xtext.thingML.SimpleParamRef;
import org.thingml.xtext.thingML.SimpleSource;
import org.thingml.xtext.thingML.StartSession;
import org.thingml.xtext.thingML.State;
import org.thingml.xtext.thingML.StateMachine;
import org.thingml.xtext.thingML.Stream;
import org.thingml.xtext.thingML.Thing;
import org.thingml.xtext.thingML.ThingMLModel;
import org.thingml.xtext.thingML.ThingMLPackage;
import org.thingml.xtext.thingML.TimeWindow;
import org.thingml.xtext.thingML.Transition;
import org.thingml.xtext.thingML.VariableAssignment;

@SuppressWarnings("all")
public class ThingMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ThingMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ThingMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ThingMLPackage.ACTION_BLOCK:
				sequence_ActionBlock(context, (ActionBlock) semanticObject); 
				return; 
			case ThingMLPackage.ARRAY_PARAM_REF:
				sequence_ArrayParamRef(context, (ArrayParamRef) semanticObject); 
				return; 
			case ThingMLPackage.COMPOSITE_STATE:
				sequence_CompositeState_Impl(context, (CompositeState) semanticObject); 
				return; 
			case ThingMLPackage.CONDITIONAL_ACTION:
				sequence_ConditionalAction(context, (ConditionalAction) semanticObject); 
				return; 
			case ThingMLPackage.CONFIG_PROPERTY_ASSIGN:
				sequence_ConfigPropertyAssign(context, (ConfigPropertyAssign) semanticObject); 
				return; 
			case ThingMLPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case ThingMLPackage.CONNECTOR:
				sequence_Connector(context, (Connector) semanticObject); 
				return; 
			case ThingMLPackage.DECREMENT:
				sequence_Decrement(context, (Decrement) semanticObject); 
				return; 
			case ThingMLPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case ThingMLPackage.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case ThingMLPackage.ERROR_ACTION:
				sequence_ErrorAction(context, (ErrorAction) semanticObject); 
				return; 
			case ThingMLPackage.EXTERN_EXPRESSION:
				sequence_ExternExpression(context, (ExternExpression) semanticObject); 
				return; 
			case ThingMLPackage.EXTERN_STATEMENT:
				sequence_ExternStatement(context, (ExternStatement) semanticObject); 
				return; 
			case ThingMLPackage.EXTERNAL_CONNECTOR:
				sequence_ExternalConnector(context, (ExternalConnector) semanticObject); 
				return; 
			case ThingMLPackage.FILTER:
				sequence_Filter(context, (Filter) semanticObject); 
				return; 
			case ThingMLPackage.FINAL_STATE:
				sequence_FinalState(context, (FinalState) semanticObject); 
				return; 
			case ThingMLPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case ThingMLPackage.FUNCTION_CALL_STATEMENT:
				sequence_FunctionCallStatement(context, (FunctionCallStatement) semanticObject); 
				return; 
			case ThingMLPackage.INCREMENT:
				sequence_Increment(context, (Increment) semanticObject); 
				return; 
			case ThingMLPackage.INSTANCE:
				sequence_Instance(context, (Instance) semanticObject); 
				return; 
			case ThingMLPackage.INSTANCE_REF:
				sequence_InstanceRef(context, (InstanceRef) semanticObject); 
				return; 
			case ThingMLPackage.INTERNAL_PORT:
				sequence_InternalPort(context, (InternalPort) semanticObject); 
				return; 
			case ThingMLPackage.INTERNAL_TRANSITION:
				sequence_InternalTransition(context, (InternalTransition) semanticObject); 
				return; 
			case ThingMLPackage.JOIN_SOURCES:
				sequence_JoinSources(context, (JoinSources) semanticObject); 
				return; 
			case ThingMLPackage.LENGTH_ARRAY:
				sequence_LengthArray(context, (LengthArray) semanticObject); 
				return; 
			case ThingMLPackage.LENGTH_WINDOW:
				sequence_LengthWindow(context, (LengthWindow) semanticObject); 
				return; 
			case ThingMLPackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case ThingMLPackage.LOOP_ACTION:
				sequence_LoopAction(context, (LoopAction) semanticObject); 
				return; 
			case ThingMLPackage.MERGE_SOURCES:
				sequence_MergeSources(context, (MergeSources) semanticObject); 
				return; 
			case ThingMLPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case ThingMLPackage.MESSAGE_PARAMETER:
				sequence_MessageParameter(context, (MessageParameter) semanticObject); 
				return; 
			case ThingMLPackage.OBJECT_TYPE:
				sequence_ObjectType(context, (ObjectType) semanticObject); 
				return; 
			case ThingMLPackage.PARALLEL_REGION:
				sequence_ParallelRegion(context, (ParallelRegion) semanticObject); 
				return; 
			case ThingMLPackage.PARAMETER:
				sequence_Parameter(context, (org.thingml.xtext.thingML.Parameter) semanticObject); 
				return; 
			case ThingMLPackage.PLATFORM_ANNOTATION:
				sequence_PlatformAnnotation(context, (PlatformAnnotation) semanticObject); 
				return; 
			case ThingMLPackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType(context, (PrimitiveType) semanticObject); 
				return; 
			case ThingMLPackage.PRINT_ACTION:
				sequence_PrintAction(context, (PrintAction) semanticObject); 
				return; 
			case ThingMLPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case ThingMLPackage.PROPERTY_ASSIGN:
				sequence_PropertyAssign(context, (PropertyAssign) semanticObject); 
				return; 
			case ThingMLPackage.PROTOCOL:
				sequence_Protocol(context, (Protocol) semanticObject); 
				return; 
			case ThingMLPackage.PROVIDED_PORT:
				sequence_ProvidedPort(context, (ProvidedPort) semanticObject); 
				return; 
			case ThingMLPackage.RECEIVE_MESSAGE:
				sequence_ReceiveMessage(context, (ReceiveMessage) semanticObject); 
				return; 
			case ThingMLPackage.REQUIRED_PORT:
				sequence_RequiredPort(context, (RequiredPort) semanticObject); 
				return; 
			case ThingMLPackage.RETURN_ACTION:
				sequence_ReturnAction(context, (ReturnAction) semanticObject); 
				return; 
			case ThingMLPackage.SEND_ACTION:
				sequence_SendAction(context, (SendAction) semanticObject); 
				return; 
			case ThingMLPackage.SESSION:
				sequence_Session(context, (Session) semanticObject); 
				return; 
			case ThingMLPackage.SIMPLE_PARAM_REF:
				sequence_SimpleParamRef(context, (SimpleParamRef) semanticObject); 
				return; 
			case ThingMLPackage.SIMPLE_SOURCE:
				sequence_SimpleSource(context, (SimpleSource) semanticObject); 
				return; 
			case ThingMLPackage.START_SESSION:
				sequence_StartSession(context, (StartSession) semanticObject); 
				return; 
			case ThingMLPackage.STATE:
				sequence_State_Impl(context, (State) semanticObject); 
				return; 
			case ThingMLPackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case ThingMLPackage.STREAM:
				sequence_Stream(context, (Stream) semanticObject); 
				return; 
			case ThingMLPackage.THING:
				sequence_Thing(context, (Thing) semanticObject); 
				return; 
			case ThingMLPackage.THING_ML_MODEL:
				sequence_ThingMLModel(context, (ThingMLModel) semanticObject); 
				return; 
			case ThingMLPackage.TIME_WINDOW:
				sequence_TimeWindow(context, (TimeWindow) semanticObject); 
				return; 
			case ThingMLPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case ThingMLPackage.VARIABLE_ASSIGNMENT:
				sequence_VariableAssignment(context, (VariableAssignment) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Action returns ActionBlock
	 *     ActionBlock returns ActionBlock
	 *
	 * Constraint:
	 *     actions+=Action*
	 */
	protected void sequence_ActionBlock(ISerializationContext context, ActionBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElmtProperty returns ArrayParamRef
	 *     ArrayParamRef returns ArrayParamRef
	 *
	 * Constraint:
	 *     parameterRef=[Parameter|ID]
	 */
	protected void sequence_ArrayParamRef(ISerializationContext context, ArrayParamRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.ARRAY_PARAM_REF__PARAMETER_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.ARRAY_PARAM_REF__PARAMETER_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayParamRefAccess().getParameterRefParameterIDTerminalRuleCall_0_0_1(), semanticObject.getParameterRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     State returns CompositeState
	 *     Region returns CompositeState
	 *     CompositeState_Impl returns CompositeState
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         initial=[State|ID] 
	 *         history?='history'? 
	 *         annotations+=PlatformAnnotation* 
	 *         entry=Action? 
	 *         exit=Action? 
	 *         (properties+=Property | substate+=State | internal+=InternalTransition | outgoing+=Transition)* 
	 *         region+=ParallelRegion*
	 *     )
	 */
	protected void sequence_CompositeState_Impl(ISerializationContext context, CompositeState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ConditionalAction
	 *     ConditionalAction returns ConditionalAction
	 *
	 * Constraint:
	 *     (condition=Expression action=Action elseAction=Action?)
	 */
	protected void sequence_ConditionalAction(ISerializationContext context, ConditionalAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConfigPropertyAssign returns ConfigPropertyAssign
	 *
	 * Constraint:
	 *     (instance=InstanceRef property=[Property|ID] index+=Expression* init=Expression annotations+=PlatformAnnotation*)
	 */
	protected void sequence_ConfigPropertyAssign(ISerializationContext context, ConfigPropertyAssign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation* (instances+=Instance | connectors+=AbstractConnector | propassigns+=ConfigPropertyAssign)*)
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractConnector returns Connector
	 *     Connector returns Connector
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         cli=InstanceRef 
	 *         required=[RequiredPort|ID] 
	 *         srv=InstanceRef 
	 *         provided=[ProvidedPort|ID] 
	 *         annotations+=PlatformAnnotation*
	 *     )
	 */
	protected void sequence_Connector(ISerializationContext context, Connector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Decrement
	 *     Decrement returns Decrement
	 *
	 * Constraint:
	 *     var=[Variable|ID]
	 */
	protected void sequence_Decrement(ISerializationContext context, Decrement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.DECREMENT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.DECREMENT__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecrementAccess().getVarVariableIDTerminalRuleCall_0_0_1(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnumerationLiteral returns EnumerationLiteral
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation*)
	 */
	protected void sequence_EnumerationLiteral(ISerializationContext context, EnumerationLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation* literals+=EnumerationLiteral*)
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ErrorAction
	 *     ErrorAction returns ErrorAction
	 *
	 * Constraint:
	 *     msg=Expression
	 */
	protected void sequence_ErrorAction(ISerializationContext context, ErrorAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.ERROR_ACTION__MSG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.ERROR_ACTION__MSG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getErrorActionAccess().getMsgExpressionParserRuleCall_1_0(), semanticObject.getMsg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExternExpression
	 *     ExternExpression returns ExternExpression
	 *
	 * Constraint:
	 *     (expression=STRING_EXT segments+=Expression*)
	 */
	protected void sequence_ExternExpression(ISerializationContext context, ExternExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ExternStatement
	 *     ExternStatement returns ExternStatement
	 *
	 * Constraint:
	 *     (statement=STRING_EXT segments+=Expression*)
	 */
	protected void sequence_ExternStatement(ISerializationContext context, ExternStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractConnector returns ExternalConnector
	 *     ExternalConnector returns ExternalConnector
	 *
	 * Constraint:
	 *     (name=ID? inst=InstanceRef port=[Port|ID] protocol=[Protocol|ID] annotations+=PlatformAnnotation*)
	 */
	protected void sequence_ExternalConnector(ISerializationContext context, ExternalConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ViewSource returns Filter
	 *     Filter returns Filter
	 *
	 * Constraint:
	 *     guard=Expression
	 */
	protected void sequence_Filter(ISerializationContext context, Filter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.FILTER__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.FILTER__GUARD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFilterAccess().getGuardExpressionParserRuleCall_2_0(), semanticObject.getGuard());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     State returns FinalState
	 *     FinalState returns FinalState
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation*)
	 */
	protected void sequence_FinalState(ISerializationContext context, FinalState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns FunctionCallStatement
	 *     FunctionCallStatement returns FunctionCallStatement
	 *
	 * Constraint:
	 *     (function=[Function|ID] parameters+=Expression parameters+=Expression*)
	 */
	protected void sequence_FunctionCallStatement(ISerializationContext context, FunctionCallStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parameters+=Parameter 
	 *         parameters+=Parameter* 
	 *         type=[Type|ID]? 
	 *         annotations+=PlatformAnnotation* 
	 *         body=Action
	 *     )
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Increment
	 *     Increment returns Increment
	 *
	 * Constraint:
	 *     var=[Variable|ID]
	 */
	protected void sequence_Increment(ISerializationContext context, Increment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.INCREMENT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.INCREMENT__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncrementAccess().getVarVariableIDTerminalRuleCall_0_0_1(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InstanceRef returns InstanceRef
	 *
	 * Constraint:
	 *     instance=[Instance|ID]
	 */
	protected void sequence_InstanceRef(ISerializationContext context, InstanceRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.INSTANCE_REF__INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.INSTANCE_REF__INSTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstanceRefAccess().getInstanceInstanceIDTerminalRuleCall_0_1(), semanticObject.getInstance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instance returns Instance
	 *
	 * Constraint:
	 *     (name=ID type=[Thing|ID] annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Instance(ISerializationContext context, Instance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Port returns InternalPort
	 *     InternalPort returns InternalPort
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation* ((sends+=[Message|ID] sends+=[Message|ID]*) | (receives+=[Message|ID] receives+=[Message|ID]*))*)
	 */
	protected void sequence_InternalPort(ISerializationContext context, InternalPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InternalTransition returns InternalTransition
	 *
	 * Constraint:
	 *     (name=ID? annotations+=PlatformAnnotation* event+=Event* guard=Expression? action=Action?)
	 */
	protected void sequence_InternalTransition(ISerializationContext context, InternalTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Source returns JoinSources
	 *     ReferencedElmt returns JoinSources
	 *     JoinSources returns JoinSources
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         sources+=Source 
	 *         sources+=Source* 
	 *         resultMessage=[Message|ID] 
	 *         rules+=Expression 
	 *         rules+=Expression* 
	 *         operators+=ViewSource*
	 *     )
	 */
	protected void sequence_JoinSources(ISerializationContext context, JoinSources semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElmtProperty returns LengthArray
	 *     LengthArray returns LengthArray
	 *
	 * Constraint:
	 *     {LengthArray}
	 */
	protected void sequence_LengthArray(ISerializationContext context, LengthArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ViewSource returns LengthWindow
	 *     LengthWindow returns LengthWindow
	 *
	 * Constraint:
	 *     (size=Expression step=Expression?)
	 */
	protected void sequence_LengthWindow(ISerializationContext context, LengthWindow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferencedElmt returns LocalVariable
	 *     Action returns LocalVariable
	 *     Variable returns LocalVariable
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     (changeable?='readonly'? name=ID type=[Type|ID] init=Expression? annotations+=PlatformAnnotation*)
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns LoopAction
	 *     LoopAction returns LoopAction
	 *
	 * Constraint:
	 *     (condition=Expression action=Action)
	 */
	protected void sequence_LoopAction(ISerializationContext context, LoopAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.LOOP_ACTION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.LOOP_ACTION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.LOOP_ACTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.LOOP_ACTION__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopActionAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getLoopActionAccess().getActionActionParserRuleCall_4_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Source returns MergeSources
	 *     ReferencedElmt returns MergeSources
	 *     MergeSources returns MergeSources
	 *
	 * Constraint:
	 *     (name=ID sources+=Source sources+=Source* resultMessage=[Message|ID] operators+=ViewSource*)
	 */
	protected void sequence_MergeSources(ISerializationContext context, MergeSources semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferencedElmt returns MessageParameter
	 *     MessageParameter returns MessageParameter
	 *
	 * Constraint:
	 *     (name=ID msgRef=[Message|ID])
	 */
	protected void sequence_MessageParameter(ISerializationContext context, MessageParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.MESSAGE_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.MESSAGE_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.MESSAGE_PARAMETER__MSG_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.MESSAGE_PARAMETER__MSG_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMessageParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMessageParameterAccess().getMsgRefMessageIDTerminalRuleCall_2_0_1(), semanticObject.getMsgRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *     ReferencedElmt returns Message
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ObjectType
	 *     ObjectType returns ObjectType
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation*)
	 */
	protected void sequence_ObjectType(ISerializationContext context, ObjectType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Region returns ParallelRegion
	 *     ParallelRegion returns ParallelRegion
	 *
	 * Constraint:
	 *     (name=ID? initial=[State|ID] history?='history'? annotations+=PlatformAnnotation* substate+=State*)
	 */
	protected void sequence_ParallelRegion(ISerializationContext context, ParallelRegion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *     ReferencedElmt returns Parameter
	 *     Variable returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=[Type|ID] annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.thingml.xtext.thingML.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlatformAnnotation returns PlatformAnnotation
	 *
	 * Constraint:
	 *     (name=ID value=STRING_LIT)
	 */
	protected void sequence_PlatformAnnotation(ISerializationContext context, PlatformAnnotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.PLATFORM_ANNOTATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.PLATFORM_ANNOTATION__NAME));
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.PLATFORM_ANNOTATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.PLATFORM_ANNOTATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlatformAnnotationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPlatformAnnotationAccess().getValueSTRING_LITTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns PrimitiveType
	 *     PrimitiveType returns PrimitiveType
	 *
	 * Constraint:
	 *     (name=ID ByteSize=INT annotations+=PlatformAnnotation*)
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, PrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns PrintAction
	 *     PrintAction returns PrintAction
	 *
	 * Constraint:
	 *     msg=Expression
	 */
	protected void sequence_PrintAction(ISerializationContext context, PrintAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.PRINT_ACTION__MSG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.PRINT_ACTION__MSG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintActionAccess().getMsgExpressionParserRuleCall_1_0(), semanticObject.getMsg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyAssign returns PropertyAssign
	 *
	 * Constraint:
	 *     (property=[Property|ID] index+=Expression* init=Expression annotations+=PlatformAnnotation*)
	 */
	protected void sequence_PropertyAssign(ISerializationContext context, PropertyAssign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *     ReferencedElmt returns Property
	 *     Variable returns Property
	 *
	 * Constraint:
	 *     (name=ID type=[Type|ID] init=Expression? annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Protocol returns Protocol
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Protocol(ISerializationContext context, Protocol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Port returns ProvidedPort
	 *     ProvidedPort returns ProvidedPort
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation* ((sends+=[Message|ID] sends+=[Message|ID]*) | (receives+=[Message|ID] receives+=[Message|ID]*))*)
	 */
	protected void sequence_ProvidedPort(ISerializationContext context, ProvidedPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferencedElmt returns ReceiveMessage
	 *     Event returns ReceiveMessage
	 *     ReceiveMessage returns ReceiveMessage
	 *
	 * Constraint:
	 *     (port=[Port|ID] message=[Message|ID])
	 */
	protected void sequence_ReceiveMessage(ISerializationContext context, ReceiveMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.RECEIVE_MESSAGE__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.RECEIVE_MESSAGE__PORT));
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.RECEIVE_MESSAGE__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.RECEIVE_MESSAGE__MESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReceiveMessageAccess().getPortPortIDTerminalRuleCall_0_0_1(), semanticObject.getPort());
		feeder.accept(grammarAccess.getReceiveMessageAccess().getMessageMessageIDTerminalRuleCall_2_0_1(), semanticObject.getMessage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Port returns RequiredPort
	 *     RequiredPort returns RequiredPort
	 *
	 * Constraint:
	 *     (
	 *         optional?='optional'? 
	 *         name=ID 
	 *         annotations+=PlatformAnnotation* 
	 *         ((sends+=[Message|ID] sends+=[Message|ID]*) | (receives+=[Message|ID] receives+=[Message|ID]*))*
	 *     )
	 */
	protected void sequence_RequiredPort(ISerializationContext context, RequiredPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ReturnAction
	 *     ReturnAction returns ReturnAction
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_ReturnAction(ISerializationContext context, ReturnAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.RETURN_ACTION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.RETURN_ACTION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnActionAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns SendAction
	 *     SendAction returns SendAction
	 *
	 * Constraint:
	 *     (port=[Port|ID] message=[Message|ID] parameters+=Expression parameters+=Expression*)
	 */
	protected void sequence_SendAction(ISerializationContext context, SendAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns Session
	 *     Region returns Session
	 *     Session returns Session
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         initial=[State|ID] 
	 *         annotations+=PlatformAnnotation* 
	 *         entry=Action? 
	 *         exit=Action? 
	 *         (properties+=Property | substate+=State | internal+=InternalTransition)* 
	 *         region+=ParallelRegion*
	 *     )
	 */
	protected void sequence_Session(ISerializationContext context, Session semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElmtProperty returns SimpleParamRef
	 *     SimpleParamRef returns SimpleParamRef
	 *
	 * Constraint:
	 *     parameterRef=[Parameter|ID]
	 */
	protected void sequence_SimpleParamRef(ISerializationContext context, SimpleParamRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingMLPackage.Literals.SIMPLE_PARAM_REF__PARAMETER_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingMLPackage.Literals.SIMPLE_PARAM_REF__PARAMETER_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleParamRefAccess().getParameterRefParameterIDTerminalRuleCall_0_1(), semanticObject.getParameterRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Source returns SimpleSource
	 *     ReferencedElmt returns SimpleSource
	 *     SimpleSource returns SimpleSource
	 *
	 * Constraint:
	 *     (name=ID message=ReceiveMessage operators+=ViewSource*)
	 */
	protected void sequence_SimpleSource(ISerializationContext context, SimpleSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns StartSession
	 *     StartSession returns StartSession
	 *
	 * Constraint:
	 *     (session=[Session|ID] constructor+=PropertyAssign*)
	 */
	protected void sequence_StartSession(ISerializationContext context, StartSession semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateMachine returns StateMachine
	 *     State returns StateMachine
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         initial=[State|ID] 
	 *         history?='history'? 
	 *         annotations+=PlatformAnnotation* 
	 *         entry=Action? 
	 *         exit=Action? 
	 *         (properties+=Property | substate+=State | internal+=InternalTransition)* 
	 *         region+=ParallelRegion*
	 *     )
	 */
	protected void sequence_StateMachine(ISerializationContext context, StateMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *     State_Impl returns State
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         annotations+=PlatformAnnotation* 
	 *         entry=Action? 
	 *         exit=Action? 
	 *         (properties+=Property | internal+=InternalTransition | outgoing+=Transition)*
	 *     )
	 */
	protected void sequence_State_Impl(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stream returns Stream
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation* input=Source (selection+=LocalVariable selection+=LocalVariable*)? output=SendAction)
	 */
	protected void sequence_Stream(ISerializationContext context, Stream semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ThingMLModel returns ThingMLModel
	 *
	 * Constraint:
	 *     (imports+=[ThingMLModel|STRING_LIT]+ | (imports+=[ThingMLModel|STRING_LIT]+ (types+=Type | protocols+=Protocol | configs+=Configuration)+))?
	 */
	protected void sequence_ThingMLModel(ISerializationContext context, ThingMLModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Thing
	 *     Thing returns Thing
	 *
	 * Constraint:
	 *     (
	 *         fragment?='fragment'? 
	 *         name=ID 
	 *         (includes+=[Thing|ID] includes+=[Thing|ID]*)? 
	 *         annotations+=PlatformAnnotation* 
	 *         (
	 *             messages+=Message | 
	 *             ports+=Port | 
	 *             properties+=Property | 
	 *             functions+=Function | 
	 *             assign+=PropertyAssign | 
	 *             behaviour+=StateMachine | 
	 *             streams+=Stream
	 *         )*
	 *     )
	 */
	protected void sequence_Thing(ISerializationContext context, Thing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ViewSource returns TimeWindow
	 *     TimeWindow returns TimeWindow
	 *
	 * Constraint:
	 *     (duration=Expression step=Expression?)
	 */
	protected void sequence_TimeWindow(ISerializationContext context, TimeWindow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         target=[State|ID] 
	 *         annotations+=PlatformAnnotation* 
	 *         event+=Event* 
	 *         guard=Expression? 
	 *         action=Action?
	 *     )
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns VariableAssignment
	 *     VariableAssignment returns VariableAssignment
	 *
	 * Constraint:
	 *     (property=[Variable|ID] index+=Expression* expression=Expression)
	 */
	protected void sequence_VariableAssignment(ISerializationContext context, VariableAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
