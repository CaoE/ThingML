/*
 * generated by Xtext 2.10.0
 */
package org.thingml.xtext.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.thingml.xtext.services.ThingMLGrammarAccess
import org.thingml.xtext.thingML.CompositeState
import org.thingml.xtext.thingML.Configuration
import org.thingml.xtext.thingML.Function
import org.thingml.xtext.thingML.InternalPort
import org.thingml.xtext.thingML.ObjectType
import org.thingml.xtext.thingML.PlatformAnnotation
import org.thingml.xtext.thingML.Port
import org.thingml.xtext.thingML.PrimitiveType
import org.thingml.xtext.thingML.Protocol
import org.thingml.xtext.thingML.ProvidedPort
import org.thingml.xtext.thingML.RequiredPort
import org.thingml.xtext.thingML.Thing
import org.thingml.xtext.thingML.ThingMLModel
import org.thingml.xtext.thingML.Type
import org.thingml.xtext.thingML.State
import org.thingml.xtext.thingML.StateContainer
import org.thingml.xtext.thingML.Region
import org.thingml.xtext.thingML.Session
import org.thingml.xtext.thingML.Action
import org.thingml.xtext.thingML.ActionBlock
import org.thingml.xtext.thingML.ConditionalAction
import org.thingml.xtext.thingML.LoopAction
import org.thingml.xtext.thingML.Message
import org.thingml.xtext.thingML.Variable
import org.thingml.xtext.thingML.Parameter
import org.thingml.xtext.thingML.FunctionCallStatement
import org.thingml.xtext.thingML.Expression
import org.thingml.xtext.thingML.Transition
import org.thingml.xtext.thingML.InternalTransition
import org.thingml.xtext.thingML.Handler
import org.thingml.xtext.thingML.Event
import org.thingml.xtext.thingML.Instance
import org.thingml.xtext.thingML.AbstractConnector
import org.thingml.xtext.thingML.Enumeration
import org.thingml.xtext.thingML.EnumerationLiteral
import org.thingml.xtext.thingML.SendAction
import org.thingml.xtext.thingML.PropertyReference
import org.thingml.xtext.thingML.EventReference
import org.thingml.xtext.constraints.ThingMLHelpers
import org.thingml.xtext.helpers.ActionHelper
import org.thingml.xtext.thingML.ExpressionGroup
import org.thingml.xtext.thingML.FunctionCallExpression
import org.thingml.xtext.thingML.ArrayIndex
import org.thingml.xtext.thingML.VariableAssignment
import org.thingml.xtext.thingML.UnaryMinus
import org.thingml.xtext.thingML.ThingMLPackage
import org.eclipse.xtext.Keyword

class ThingMLFormatter extends AbstractFormatter2 {
	
	@Inject extension ThingMLGrammarAccess

	def dispatch void format(ThingMLModel thingMLModel, extension IFormattableDocument document) {
		//println(textRegionAccess.toString())
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		
		for (Type types : thingMLModel.getTypes()) {
			types.format;
		}
		for (Protocol protocols : thingMLModel.getProtocols()) {
			protocols.format;
		}
		for (Configuration configs : thingMLModel.getConfigs()) {
			configs.format;
		}
		
		//Formats all expressions in the model, so that we do not need to manually find expressions in if, guards, etc
		for(Expression e : ThingMLHelpers.getAllExpressions(thingMLModel)) {
			e.format
		}
	}	
	
	def dispatch void format(Configuration cfg, extension IFormattableDocument document) {
		cfg.interior[indent]
		cfg.regionFor.keyword("{").append[newLine]
		cfg.regionFor.keyword("}").prepend[newLine]
		for(Instance i : cfg.instances) {
			i.append[newLine]
		}
		for(AbstractConnector c : cfg.connectors) {
			c.append[newLine]
		}
		cfg.append[setNewLines(2,2,Integer.MAX_VALUE)]
	}

	def dispatch void format(Protocol p, extension IFormattableDocument document) {
		p.interior[indent]
		for (PlatformAnnotation annotations : p.getAnnotations()) {
			annotations.format;
			if (p.getAnnotations.size > 1) {
				annotations.prepend[newLine]
			}
		}
		p.append[setNewLines(1,2,Integer.MAX_VALUE)]
	}
	
	def dispatch void format(Enumeration e, extension IFormattableDocument document) {		
		formatType(e, document) 
		e.regionFor.keyword("{").append[newLine]
		e.regionFor.keyword("}").prepend[newLine]
		for(EnumerationLiteral l : e.literals) {
			l.append[newLine]
		}
	}

	def dispatch void format(PrimitiveType primitiveType, extension IFormattableDocument document) {
		primitiveType.regionFor.keyword("<").surround[noSpace]
		primitiveType.regionFor.keyword(">").prepend[noSpace]		
		formatType(primitiveType, document) 
	}
	
	def dispatch void format(ObjectType objectType, extension IFormattableDocument document) {
		formatType(objectType, document)
	}
	
	def dispatch void format(Thing thing, extension IFormattableDocument document) {
		thing.interior[indent]
		for(org.thingml.xtext.thingML.Property p : thing.properties) {
			p.format
			if(thing.properties.last === p)
				thing.append[newLine]
		}		
		for(Port p : thing.ports) {
			p.format
			if(thing.ports.last === p)
				thing.append[newLine]
		}
		for(Message m : thing.messages) {
			m.format
			if(thing.messages.last === m)
				thing.append[newLine]
		}
		for (Function function : thing.functions) {
			function.format;
			if(thing.functions.last === function)
				thing.append[newLine]
		}
		for (CompositeState state : thing.behaviour) {
			state.format;
		}
		thing.regionFor.keyword("{").append[newLine]
		thing.regionFor.keyword("}").prepend[newLine]
		thing.append[setNewLines(2,2,Integer.MAX_VALUE)]
	}
	
	def dispatch void format(Message message, extension IFormattableDocument document) {
		message.regionFor.keyword("(").append[noSpace].prepend[noSpace]
		message.regionFor.keyword(")").append[noSpace].prepend[noSpace]
		for(Parameter p : message.parameters) {
			if (message.parameters.indexOf(p) !== 0)
				p.prepend[space = " "]
			p.append[noSpace]	
		}
		message.append[setNewLines(1,2,Integer.MAX_VALUE)]
	}
	
	def dispatch void format(Port port, extension IFormattableDocument document) {
		formatPort(port, document)
	}
	
	def dispatch void format(RequiredPort requiredPort, extension IFormattableDocument document) {
		formatPort(requiredPort, document)
	}
	
	def dispatch void format(ProvidedPort providedPort, extension IFormattableDocument document) {
		formatPort(providedPort, document)
	}

	def dispatch void format(InternalPort internalPort, extension IFormattableDocument document) {
		formatPort(internalPort, document)
	}
	
	def dispatch void format(Function function, extension IFormattableDocument document) {
		function.regionFor.keyword("(").append[noSpace].prepend[noSpace]
		function.regionFor.keyword(")").append[noSpace].prepend[noSpace]
		for(Parameter p : function.parameters) {
			if (function.parameters.indexOf(p) !== 0)
				p.prepend[space = " "]
			p.append[noSpace]	
		}
		if (function.body !== null)
			function.body.format			
		function.append[setNewLines(2,2,Integer.MAX_VALUE)]
	}
	
	def dispatch void format(State state, extension IFormattableDocument document) {
		formatState(state, document)		
	}
	
	def dispatch void format(CompositeState state, extension IFormattableDocument document) {
		formatState(state, document)
		for (State sub : state.substate) {
			sub.format;
		}
		for(Region r : state.region) {
			formatStateContainer(r, document)
		}	
		for(Session s : state.session) {
			formatStateContainer(s, document)
		}	
	}
	
	def dispatch void format(Variable variable, extension IFormattableDocument document) {
		variable.interior[indent]
		variable.append[setNewLines(1,2,Integer.MAX_VALUE)]		
	}
	
	def dispatch void format(Action action, extension IFormattableDocument document) {
		for(Expression e : ThingMLHelpers.getAllExpressions(action)) {
			e.format
		}
		action.interior[indent]
		action.append[setNewLines(1,2,Integer.MAX_VALUE)]		
	}
	
	def dispatch void format(SendAction action, extension IFormattableDocument document) {
		action.regionFor.keyword("!").append[noSpace].prepend[noSpace]
		action.regionFor.keyword("(").append[noSpace].prepend[noSpace]
		action.regionFor.keyword(")").append[noSpace].prepend[noSpace]
		for(Expression p : action.parameters) {
			p.prepend[space = " "]
			p.append[noSpace]	
		}
		action.append[newLine]		
	}	
	
	def dispatch void format(FunctionCallStatement action, extension IFormattableDocument document) {
		action.regionFor.keyword("(").append[noSpace].prepend[noSpace]
		action.regionFor.keyword(")").append[noSpace].prepend[noSpace]
		for(Expression p : action.parameters) {
			p.prepend[space = " "]
			p.append[noSpace]	
		}	
		action.append[newLine]	
	}	
	
	def dispatch void format(FunctionCallExpression exp, extension IFormattableDocument document) {
		exp.regionFor.keyword("(").append[noSpace].prepend[noSpace]
		exp.regionFor.keyword(")").append[noSpace].prepend[noSpace]
		for(Expression p : exp.parameters) {
			p.prepend[space = " "]
			p.append[noSpace]
		}		
	}	
	
	def dispatch void format(ActionBlock action, extension IFormattableDocument document) {		
		action.interior[indent]
		action.regionFor.keyword("do").append[newLine]
		action.regionFor.keyword("end").prepend[newLine]
		for(Action a : action.actions) {
			a.format
		}
		action.append[newLine]
	}
	
	def dispatch void format(ConditionalAction action, extension IFormattableDocument document) {
		action.action.format
		action.regionFor.keyword("(").append[noSpace]
		action.regionFor.keyword(")").prepend[noSpace]
		if (action.elseAction !== null) {
			action.elseAction.format	
		}		
	}
	
	def dispatch void format(VariableAssignment action, extension IFormattableDocument document) {
		action.regionFor.keyword("[").prepend[noSpace].append[noSpace]
		action.regionFor.keyword("]").prepend[noSpace]
	}	
	
	def dispatch void format(LoopAction action, extension IFormattableDocument document) {
		action.regionFor.keyword("(").append[noSpace]
		action.regionFor.keyword(")").prepend[noSpace]
		action.action.format		
	}
	
	def dispatch void format(PropertyReference exp, extension IFormattableDocument document) {
		exp.regionFor.keyword(".").append[noSpace].prepend[noSpace]
	}
	
	def dispatch void format(EventReference exp, extension IFormattableDocument document) {
		exp.regionFor.keyword(".").append[noSpace].prepend[noSpace]
	}
	
	def dispatch void format(ExpressionGroup exp, extension IFormattableDocument document) {
		exp.regionFor.keyword("(").append[noSpace]
		exp.regionFor.keyword(")").prepend[noSpace]
	}

	def dispatch void format(ArrayIndex exp, extension IFormattableDocument document) {
		exp.regionFor.keyword("[").append[noSpace]
		exp.regionFor.keyword("]").prepend[noSpace]
	}
			
	def dispatch void format(UnaryMinus exp, extension IFormattableDocument document) {
		exp.regionFor.keyword("-").append[noSpace]
	}				
	
	// TODO: implement for , Enumeration, EnumerationLiteral, Thing, PropertyAssign, Protocol, Function, Property, Message, Parameter, , , , Stream, JoinSources, MergeSources, SimpleSource, Filter, LengthWindow, TimeWindow, StateMachine, FinalState, CompositeState, Session, ParallelRegion, State, Transition, InternalTransition, ActionBlock, ExternStatement, LocalVariable, SendAction, VariableAssignment, LoopAction, ConditionalAction, ReturnAction, PrintAction, ErrorAction, StartSession, FunctionCallStatement, ExternExpression, Configuration, Instance, ConfigPropertyAssign, Connector, ExternalConnector
	
	def dispatch void format(Handler h, extension IFormattableDocument document) {
		if (h.event.size > 0)
			h.regionFor.keyword("event").prepend[newLine]
		for(Event e : h.event) {
			e.regionFor.keyword("?").prepend[noSpace].append[noSpace]
			e.append[newLine]				
		}
		if (h.guard !== null) {
			h.guard.append[newLine]
		}
		if (h.action !== null) {
			h.action.format
		}
		h.append[setNewLines(1,2,Integer.MAX_VALUE)]		
	}
	
	/* --- Helpers --- */
	
	
	def void formatStateContainer(StateContainer container, extension IFormattableDocument document) {
		for(State sub : container.substate) {
			sub.format
		}
		container.interior[indent]
		container.regionFor.keyword("{").append[newLine]
		container.regionFor.keyword("}").prepend[newLine]
		container.append[setNewLines(1,2,Integer.MAX_VALUE)]
	}
	
	def void formatState(State state, extension IFormattableDocument document) {
		if (state.entry !== null)
			state.entry.format
		if (state.exit !== null)
			state.exit.format	
		for(Transition t: state.outgoing) {
			t.format
		}
		for(InternalTransition t: state.internal) {
			t.format
		}
		state.interior[indent]
		state.regionFor.keyword("{").append[newLine]
		state.regionFor.keyword("}").prepend[newLine]
		state.append[setNewLines(2,2,Integer.MAX_VALUE)]
	}
	
	def void formatType(Type type, extension IFormattableDocument document) {
		type.interior[indent]
		for (PlatformAnnotation annotations : type.getAnnotations()) {
			annotations.format;
			if (type.getAnnotations.size > 1) {
				annotations.prepend[newLine]
			}
		}
		type.append[setNewLines(1,2,Integer.MAX_VALUE)]
	}
	
	def void formatPort(Port port, extension IFormattableDocument document) {
		//FIXME: we should have: sends a, b, c and not sends a sends b sends c
		port.regionFor.keyword("{").append[newLine]
		port.regionFor.keyword("}").prepend[newLine]
		port.interior[indent]

		for(Message m : port.receives) {
			//m.format
			m.append[newLine]
		}
					
		for(Message m : port.receives) {
			//m.format
			m.append[newLine]
		}
		port.append[setNewLines(1,2,Integer.MAX_VALUE)]
	}
}
