thing MQTTAdapterTest includes MQTTAdapterMsgs , TimerMsgs {
	required port clock {
		sends timer_start sends timer_cancel receives timer_timeout
	}
	required port mqtt @sync_send "true" {
		sends mqtt_connect sends mqtt_disconnect sends mqtt_publish sends mqtt_subscribe sends mqtt_set_credentials sends mqtt_set_prefix receives mqtt_connected receives mqtt_disconnected receives mqtt_message
	}
	readonly property client_id : String = "TestClient1"
	property broker_host : String = "localhost"
	property broker_port : UInt16 = 1883
	property broker_user : String = `null`
	property broker_pass : String = `null`
	property broker_tls : Boolean = false
	readonly property timer_id : UInt8 = 0
	function publish_hello() do
		mqtt!mqtt_publish("Hello", `"World".getBytes()`, 5)
	end
	statechart MQTTAdapterTestSC init DISCONNECTED {
		on entry do
			if (broker_user != `null`) mqtt!mqtt_set_credentials(broker_user, broker_pass)
			mqtt!mqtt_connect(client_id, broker_host, broker_port, broker_tls)
		end
		state DISCONNECTED {
			transition -> CONNECTED
			event mqtt?mqtt_connected
			action print "Client got mqtt_connected\n"
		}
		state CONNECTED {
			on entry do
				mqtt!mqtt_set_prefix("models18/")
				mqtt!mqtt_subscribe("#")
				publish_hello()
				clock!timer_start(timer_id, 5000)
			end
			internal
			event e : clock?timer_timeout
			guard e.id == timer_id
			action do
				publish_hello()
				clock!timer_start(timer_id, 5000)
			end
			internal
			event m : mqtt?mqtt_message
			action do
				`System.out.println("RCV topic:"+` & m.topic & `+" payload:" + ` & m.payload & `);`
			end
			transition -> DISCONNECTED
			event mqtt?mqtt_disconnected
			action print "Client got mqtt_disconnected\n"
		}
	}
}
object MQTTMessage @java_type "org.eclipse.paho.client.mqttv3.MqttMessage"
object Throwable @java_type "Throwable"
object IMqttDeliveryToken @java_type "IMqttDeliveryToken"
thing JavaMQTTAdapter includes MQTTAdapterMsgs @maven_dep "		
		<dependency>
			<groupId>org.eclipse.paho</groupId>
			<artifactId>org.eclipse.paho.client.mqttv3</artifactId>
			<version>1.2.0</version>
		</dependency>

		<dependency>
			<groupId>org.json</groupId>
			<artifactId>org.json</artifactId>
			<version>chargebee-1.0</version>
		</dependency>" @java_interface "org.eclipse.paho.client.mqttv3.MqttCallbackExtended" @java_import "import java.util.logging.Logger;" @java_import "import java.util.logging.Level;" @java_import "import org.eclipse.paho.client.mqttv3.*;" @java_import "import org.eclipse.paho.client.mqttv3.persist.*;" @java_features "org.eclipse.paho.client.mqttv3.MqttClient clientPub, clientSub;" {
	provided port mqtt @sync_send "true" {
		sends mqtt_connected sends mqtt_disconnected sends mqtt_message receives mqtt_connect receives mqtt_disconnect receives mqtt_publish receives mqtt_subscribe receives mqtt_set_credentials receives mqtt_set_prefix
	}
	property broker_uri : String = "tcp://localhost:1883"
	property client_id : String = `null`
	property username : String = `null`
	property password : String = `null`
	property topic_prefix : String = `null`
	function setTopicPrefix(src : String) do
		topic_prefix = src
	end
	function mqtt_connect() : Boolean do
	`try {`
	`MemoryPersistence persistence = new MemoryPersistence();`
		`Logger.getLogger(this.getClass().getName()).log(Level.INFO, "MQTT Connect to: " + ` & broker_uri & `);`
	`MqttConnectOptions connOpts = new MqttConnectOptions();`
	`connOpts.setCleanSession(true);`
	`connOpts.setAutomaticReconnect(true);`
		if (username != `null` and password != `null`) do
			`connOpts.setUserName(` & username & `);`
			`connOpts.setPassword(` & password & `.toCharArray());`
		end
		if (client_id == `null`) do
			client_id = `MqttClient.generateClientId()`
		end
		`clientSub = new MqttClient(` & broker_uri & `, ` & client_id & ` + "_Sub", persistence);`
		`clientPub = new MqttClient(` & broker_uri & `, ` & client_id & ` + "_Pub", persistence);`
	`clientSub.	setCallback(this);`
	`clientSub.connect(connOpts);`
	`clientPub.connect(connOpts);`
	`} catch (org.eclipse.paho.client.mqttv3.MqttException ex) {`
	`Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);`
		return false
	`}`
		return true
	end
	function mqtt_publish(topic : String, payload : Buffer, size : UInt16) : Boolean do
		if (`clientPub == null`) return false
		`try {
            Logger.getLogger(this.getClass().getName()).log(Level.INFO, "MQTT Publish: " + ` & topic & ` + " -> " + new String(` & payload & `));
            MqttMessage message = new MqttMessage(` & payload & `);
            if (` & topic_prefix & ` != null) clientPub.publish(` & topic_prefix & ` + ` & topic & `, message);
            else clientPub.publish(` & topic & `, message);
        } catch (org.eclipse.paho.client.mqttv3.MqttException ex) {
            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);`
		return false
	`}`
		return true
	end
	function mqtt_subscribe(topic : String) : Boolean do
		if (`clientSub == null`) return false
		`try {
            Logger.getLogger(this.getClass().getName()).log(Level.INFO, "MQTT Subscribe: " + ` & topic & `);
            if (` & topic_prefix & ` != null) clientSub.subscribe(` & topic_prefix & ` + ` & topic & `);
            else clientSub.subscribe(` & topic & `);
        } catch (org.eclipse.paho.client.mqttv3.MqttException ex) {
            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);`
		return false
	`}`
		return true
	end
	function messageArrived(topic : String, m : MQTTMessage) @override "true" do
		print "Message arrived on topic "
		print topic
		print "\n"
	end
	function connectionLost(t : Throwable) @override "true" do
		print "connectionLost \n"
		mqtt!mqtt_disconnected()
	end
	function deliveryComplete(imdt : IMqttDeliveryToken) @override "true" do
		print "deliveryComplete \n"
	end
	function connectComplete(reconnect : Boolean, serverURI : String) @override "true" do
		print "connectComplete \n"
		mqtt!mqtt_connected()
	end
	statechart MQTTAdapterThing init Start {
		state Start {
		}
		internal
		event m : mqtt?mqtt_set_credentials
		action do
			username = m.usr
			password = m.pwd
		end
		internal
		event m : mqtt?mqtt_set_prefix
		action do
			setTopicPrefix(m.prefix)
		end
		internal
		event m : mqtt?mqtt_connect
		action do
			client_id = m.client_id
		`String uri;`
			if (m.tls) `uri = "ssl://";`
			else `uri = "tcp://";`
			`uri += ` & m.host & ` + ":" + ` & m.portno & `;`
			broker_uri = `uri`
			mqtt_connect()
		end
		internal
		event m : mqtt?mqtt_publish
		action do
			mqtt_publish(m.topic, m.payload, m.size)
		end
		internal
		event m : mqtt?mqtt_subscribe
		action do
			mqtt_subscribe(m.topic)
		end
	}
}
thing fragment TimerMsgs {
	message timer_start(id : UInt8, time : UInt16)
	message timer_cancel(id : UInt8)
	message timer_timeout(id : UInt8)
}
thing fragment TimerClientPort includes TimerMsgs {
	required port timer {
		sends timer_start sends timer_cancel receives timer_timeout
	}
}
thing fragment Timer includes TimerMsgs {
	provided port timer {
		sends timer_timeout receives timer_start receives timer_cancel
	}
}
thing TimerJava includes Timer @java_import "import java.util.*;" @java_features "
	Hashtable<Integer, TimerTask> tasks = new Hashtable<Integer, TimerTask>();
	Timer timer = new java.util.Timer();" {
	function startTimer(id : UInt8, delay : UInt16) do
		cancel(id)
		`final int t_id = ` & id & `;`
	`TimerTask t =  new TimerTask() { public void run(){`
		timer!timer_timeout(`t_id` as UInt8)
		`
        } };
        tasks.put(t_id, t);
        timer.schedule(t, ` & delay & `);`
	end
	function cancel(id : UInt8) do
		`TimerTask t = tasks.get(` & id & `);`
	`if (t != null) t.cancel();`
	`timer.purge();`
	end
	statechart SoftTimer init default {
		state default {
			internal
			event m : timer?timer_start
			guard m.time > 0
			action startTimer(m.id, m.time)
			internal cancel
			event m : timer?timer_cancel
			action cancel(m.id)
		}
	}
}
object JSArray
thing TimerJS includes Timer {
	property Timeouts : JSArray = `{}` as JSArray
	function startTimer(id : UInt8, delay : UInt16) do
		`
      if (` & Timeouts & `[` & id & `] != undefined) {
        `
		cancel(id)
		`
      }
      
      ` & Timeouts & `[` & id & `] = setTimeout(() => {
        `
		timer!timer_timeout(id)
		`
        ` & Timeouts & `[` & id & `] = undefined;
      }, ` & delay & `);
    `
	end
	function cancel(id : UInt8) do
		`
        if (` & Timeouts & `[` & id & `] != undefined) {
          clearTimeout(` & Timeouts & `[` & id & `]);
          ` & Timeouts & `[` & id & `] = undefined;
        }
      `
	end
	statechart SoftTimer init default {
		state default {
			internal
			event m : timer?timer_start
			guard m.time > 0
			action startTimer(m.id, m.time)
			internal cancel
			event m : timer?timer_cancel
			action cancel(m.id)
		}
	}
}
thing TimerPosix includes Timer @c_header "
#include <time.h>
#include <unistd.h>
#include <pthread.h>

#define NB_SOFT_TIMERS 16
" @c_global "uint32_t Timer_timeouts[NB_SOFT_TIMERS];
uint8_t  Timer_wraps[NB_SOFT_TIMERS];
uint32_t Timer_prev;
pthread_mutex_t Timer_mut;" {
	readonly property NB_SOFT_TIMERS : UInt16 = `NB_SOFT_TIMERS` as UInt16
	readonly property SOFT_TIMER_PERIOD : UInt16 = 4
	function time_ms() : UInt32 do
	`struct timespec current;
		int res;
		uint32_t millis = 0;
		
		res = clock_gettime(CLOCK_MONOTONIC, &current);
		if (res != 0) {
			  perror("[ERROR]: Could not get current time : ");
		 } else {
			  millis  =  current.tv_sec * 1000;
			  millis += current.tv_nsec / 1000000;
		}`
		return `millis` as UInt32
	end
	function sleep_ms(timeout_ms : UInt16) do
		`struct timeval tv;
        tv.tv_sec = ` & timeout_ms & `/1000;
        tv.tv_usec = (` & timeout_ms & `%1000) * 1000;
        select(0, NULL, NULL, NULL, &tv);`
	end
	function start_soft_timer_process() @fork_linux_thread "true" do
		`pthread_mutex_init(&Timer_mut, NULL);
	    uint8_t i;
	    for (i = 0; i < ` & NB_SOFT_TIMERS & `; i++) {
	        Timer_timeouts[i] = 0;
	        Timer_wraps[i] = 0;
	    }
	    Timer_prev = ` & time_ms()& `;`
		while (true) do
			sleep_ms(SOFT_TIMER_PERIOD)
			`pthread_mutex_lock(&Timer_mut);
	        uint32_t current = ` & time_ms()& `;
	        uint8_t i;
	        for (i = 0; i < ` & NB_SOFT_TIMERS & `; i++) {
	            if (Timer_timeouts[i] > 0) {
	                if (current >= Timer_prev) {
	                    // Normal time progression
	                    if (current > Timer_timeouts[i] && Timer_wraps[i] == 0) {`
			timer!timer_timeout(`i` as UInt8)
		`Timer_timeouts[i] = 0;
	                        Timer_wraps[i] = 0;
	                    }
	                } else {
	                    // A wraparound has occurred
	                    if (Timer_wraps[i] == 0) {`
			timer!timer_timeout(`i` as UInt8)
		`Timer_timeouts[i] = 0;
	                    } else {
	                        Timer_wraps[i] = 0;
	                        if (current > Timer_timeouts[i]) {`
			timer!timer_timeout(`i` as UInt8)
		`Timer_timeouts[i] = 0;
	                        }
	                    }
	                }
	            }
	        }
	        Timer_prev = current;
	        pthread_mutex_unlock(&Timer_mut);`
		end
	end
	function startTimer(id : UInt8, delay : UInt16) do
		`
    	if (` & id & ` < NB_SOFT_TIMERS) {
	        uint32_t current = ` & time_ms()& `;
	        uint32_t timeout = current + ` & delay & `;
	        if (timeout == 0) timeout = 1;
	
	        pthread_mutex_lock(&Timer_mut);
	        Timer_timeouts[` & id & `] = timeout;
	        Timer_wraps[` & id & `] = (timeout > current) ? 0 : 1;
	        pthread_mutex_unlock(&Timer_mut);
	    }
    `
	end
	function cancel(id : UInt8) do
		`
        if (` & id & ` < NB_SOFT_TIMERS) {
	        pthread_mutex_lock(&Timer_mut);
	        Timer_timeouts[` & id & `] = 0;
	        Timer_wraps[` & id & `] = 0;
	        pthread_mutex_unlock(&Timer_mut);
	    }
      `
	end
	statechart SoftTimer init default {
		on entry start_soft_timer_process()
		state default {
			internal
			event m : timer?timer_start
			guard m.time > 0
			action startTimer(m.id, m.time)
			internal cancel
			event m : timer?timer_cancel
			action cancel(m.id)
		}
	}
}
thing TimerArduino includes Timer @c_header "
#define NB_SOFT_TIMERS 16
" @c_global "uint32_t Timer_timeouts[NB_SOFT_TIMERS];
uint8_t  Timer_wraps[NB_SOFT_TIMERS];
uint32_t Timer_prev;" {
	readonly property NB_SOFT_TIMERS : UInt16 = `NB_SOFT_TIMERS` as UInt16
	function time_ms() : UInt32 do
		return `millis()` as UInt32
	end
	function init_arrays() do
		`uint8_t i;
	    for (i = 0; i < ` & NB_SOFT_TIMERS & `; i++) {
	        Timer_timeouts[i] = 0;
	        Timer_wraps[i] = 0;
	    }
	    Timer_prev = ` & time_ms()& `;`
	end
	function poll_soft_timers() @scheduler_polling "true" do
		`uint32_t current = ` & time_ms()& `;
		uint8_t i;
		for (i = 0; i < ` & NB_SOFT_TIMERS & `; i++) {
		    if (Timer_timeouts[i] > 0) {
		        if (current >= Timer_prev) {
		            // Normal time progression
		            if (current > Timer_timeouts[i] && Timer_wraps[i] == 0) {`
		timer!timer_timeout(`i` as UInt8)
	`Timer_timeouts[i] = 0;
		                Timer_wraps[i] = 0;
		            }
		        } else {
		            // A wraparound has occurred
		            if (Timer_wraps[i] == 0) {`
		timer!timer_timeout(`i` as UInt8)
	`Timer_timeouts[i] = 0;
		            } else {
		                Timer_wraps[i] = 0;
		                if (current > Timer_timeouts[i]) {`
		timer!timer_timeout(`i` as UInt8)
	`Timer_timeouts[i] = 0;
		                }
		            }
		        }
		    }
		}`
	end
	function startTimer(id : UInt8, delay : UInt16) do
		`
    	if (` & id & ` < NB_SOFT_TIMERS) {
	        uint32_t current = ` & time_ms()& `;
	        uint32_t timeout = current + ` & delay & `;
	        if (timeout == 0) timeout = 1;
	
	        Timer_timeouts[` & id & `] = timeout;
	        Timer_wraps[` & id & `] = (timeout > current) ? 0 : 1;
	    }
    `
	end
	function cancel(id : UInt8) do
		`
        if (` & id & ` < NB_SOFT_TIMERS) {
	        Timer_timeouts[` & id & `] = 0;
	        Timer_wraps[` & id & `] = 0;
	    }
      `
	end
	statechart SoftTimer init default {
		on entry init_arrays()
		state default {
			internal
			event m : timer?timer_start
			guard m.time > 0
			action startTimer(m.id, m.time)
			internal cancel
			event m : timer?timer_cancel
			action cancel(m.id)
		}
	}
}
object Buffer
	@java_type " byte[]"
	@java_primitive "true"
	@c_type "uint8_t *"
	@c_byte_size "*"
thing MQTTAdapterMsgs {
	message mqtt_set_credentials(usr : String, pwd : String)
	message mqtt_set_tls_certificates(cafile : String, capath : String, certfile : String, keyfile : String)
	message mqtt_connect(client_id : String, host : String, portno : UInt16, tls : Boolean)
	message mqtt_disconnect()
	message mqtt_connected()
	message mqtt_disconnected()
	message mqtt_publish(topic : String, payload : Buffer, size : UInt32)
	message mqtt_subscribe(topic : String)
	message mqtt_set_prefix(prefix : String)
	message mqtt_message(topic : String, payload : Buffer, size : UInt32)
}
thing MQTTAdapterCtrlPort includes MQTTAdapterMsgs {
	required port mqtt @sync_send "true" {
		sends mqtt_connect sends mqtt_disconnect receives mqtt_connected receives mqtt_disconnected
	}
}
datatype Byte<1>
	@type_checker "Byte"
	@c_type "uint8_t"
	@c_byte_size "1"
	@java_type "byte"
	@js_type "byte"
	@java_primitive "true"
	@go_type "byte"
datatype Char<1>
	@type_checker "Byte"
	@c_type "char"
	@c_byte_size "1"
	@java_type "byte"
	@js_type "byte"
	@java_primitive "true"
	@go_type "byte"
datatype Boolean<1>
	@type_checker "Boolean"
	@c_type "bool"
	@c_byte_size "1"
	@java_type "boolean"
	@js_type "boolean"
	@java_primitive "true"
	@go_type "bool"
datatype Integer<2>
	@type_checker "Integer"
	@c_type "int"
	@c_byte_size "2"
	@java_type "short"
	@js_type "short"
	@java_primitive "true"
	@go_type "int16"
datatype UInt8<1>
	@type_checker "Integer"
	@c_type "uint8_t"
	@c_byte_size "1"
	@java_type "short"
	@js_type "short"
	@java_primitive "true"
	@go_type "uint8"
datatype Int8<1>
	@type_checker "Integer"
	@c_type "int8_t"
	@c_byte_size "1"
	@java_type "byte"
	@js_type "byte"
	@java_primitive "true"
	@go_type "int8"
datatype UInt16<2>
	@type_checker "Integer"
	@c_type "uint16_t"
	@c_byte_size "2"
	@java_type "int"
	@js_type "int"
	@java_primitive "true"
	@go_type "uint16"
datatype Int16<2>
	@type_checker "Integer"
	@c_type "int16_t"
	@c_byte_size "2"
	@java_type "short"
	@js_type "short"
	@java_primitive "true"
	@go_type "int16"
datatype Int32<4>
	@type_checker "Integer"
	@c_type "int32_t"
	@c_byte_size "4"
	@java_type "int"
	@js_type "int"
	@java_primitive "true"
	@go_type "int32"
datatype UInt32<4>
	@type_checker "Integer"
	@c_type "uint32_t"
	@c_byte_size "4"
	@java_type "long"
	@js_type "long"
	@java_primitive "true"
	@go_type "uint32"
datatype Long<4>
	@type_checker "Integer"
	@c_type "long"
	@c_byte_size "4"
	@java_type "int"
	@js_type "int"
	@java_primitive "true"
	@go_type "int32"
datatype ULong<4>
	@type_checker "Integer"
	@c_type "unsigned long"
	@c_byte_size "4"
	@java_type "long"
	@js_type "long"
	@java_primitive "true"
	@go_type "uint32"
datatype LongLong<8>
	@type_checker "Integer"
	@c_type "long long"
	@c_byte_size "8"
	@java_type "long"
	@js_type "long"
	@java_primitive "true"
	@go_type "int64"
datatype Float<4>
	@type_checker "Real"
	@c_type "float"
	@c_byte_size "4"
	@java_type "float"
	@js_type "float"
	@java_primitive "true"
	@go_type "float32"
datatype Double<8>
	@type_checker "Real"
	@c_type "double"
	@c_byte_size "8"
	@java_type "double"
	@js_type "double"
	@java_primitive "true"
	@go_type "float64"
object String
	@serializable
	@c_type "char *"
	@c_byte_size "*"
	@java_type "String"
	@js_type "String"
	@go_type "string"
enumeration DigitalState
	@type_checker "Integer"
	@java_type "byte"
	@java_primitive "true"
	@c_byte_size "1"
	@c_type "uint8_t"
	@go_type "uint8"
	{
	LOW @enum_val "0"
	HIGH @enum_val "1"
}
configuration MQTTAdapterTest {
	instance adapter1 : JavaMQTTAdapter
	instance timer : TimerJava
	instance test1 : MQTTAdapterTest
	connector test1.mqtt => adapter1 . mqtt
	connector test1.clock => timer . timer
	set test1.client_id = "Test1"
	set test1.broker_host = "mqtt.tutorials.tellucloud.com"
	set test1.broker_port = 1883
	set test1.broker_user = "models18"
	set test1.broker_pass = "thingml"
	set test1.broker_tls = false
	set test1.timer_id = 1
}
